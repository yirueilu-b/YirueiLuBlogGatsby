{"componentChunkName":"component---src-templates-post-js","path":"/blog/34c685","result":{"pageContext":{"md_path":"leetcode1041","title":"LeetCode 1041. Robot Bounded In Circle","description":"On an infinite plane, a robot initially stands at (0, 0) and faces north.  The robot can receive one of three instructions:The robot performs the inst...","image":"https://dkmonster.github.io/assets/images/leetcode/LeetCode_Sharing.png","uuid":"34c685","text":"# LeetCode 1041. Robot Bounded In Circle\r\n\r\n![](https://dkmonster.github.io/assets/images/leetcode/LeetCode_Sharing.png)\r\n\r\n## Description\r\n\r\nOn an infinite plane, a robot initially stands at (0, 0) and faces north.  The robot can receive one of three instructions:\r\n\r\n- ``\"G\"``: go straight 1 unit;\r\n- ``\"L\"``: turn 90 degrees to the left;\r\n- ``\"R\"``: turn 90 degress to the right.\r\n\r\nThe robot performs the instructions given in order, and repeats them forever.\r\n\r\nReturn true if and only if there exists a circle in the plane such that the robot never leaves the circle.\r\n\r\n**Example 1:**\r\n```\r\nInput: \"GGLLGG\"\r\nOutput: true\r\nExplanation: \r\nThe robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).\r\nWhen repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.\r\n```\r\n\r\n**Example 2:**\r\n```\r\nInput: \"GG\"\r\nOutput: false\r\nExplanation: \r\nThe robot moves north indefinitely.\r\n```\r\n\r\n**Example 3:**\r\n```\r\nInput: \"GL\"\r\nOutput: true\r\nExplanation: \r\nThe robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ...\r\n```\r\nNote:\r\n\r\n- 1 <= instructions.length <= 100\r\n- instructions[i] is in {'G', 'L', 'R'}\r\n\r\n## Idea\r\n\r\nFollow the given instructions to move the robot then check some conditions to determine if it is in a circle.\r\n\r\nThe first condition to check is the final position of the robot and its initial position. It's trivial that if the positions are the same, it is in a circle.\r\n\r\nThe second condition is checking the initial and final directions. The robot's initial direction is North, if its final direction is not the same as its initial direction then it is in a circle.\r\n\r\n## Solution\r\n\r\n```python\r\nclass Solution:\r\n    def isRobotBounded(self, instructions: str) -> bool:\r\n        init_position = [0, 0]\r\n        position = [0, 0]\r\n        init_direction = (0, 1)\r\n        direction = (0, 1)\r\n        for instruction in instructions:\r\n            if instruction == \"G\":\r\n                position[0] += direction[0]\r\n                position[1] += direction[1]\r\n            elif instruction == \"L\":\r\n                if direction == (0, 1):\r\n                    direction = (-1, 0)\r\n                elif direction == (-1, 0):\r\n                    direction = (0, -1)\r\n                elif direction == (0, -1):\r\n                    direction = (1, 0)\r\n                else:\r\n                    direction = (0, 1)\r\n            else:\r\n                if direction == (0, 1):\r\n                    direction = (1, 0)\r\n                elif direction == (1, 0):\r\n                    direction = (0, -1)\r\n                elif direction == (0, -1):\r\n                    direction = (-1, 0)\r\n                else:\r\n                    direction = (0, 1)\r\n        return init_position == position or init_direction != direction\r\n```\r\n\r\n> **Complexity**\r\n> - Time complexity: `O(n)`        \r\n>   Iterate through `n` given instructions\r\n> - Space complexity: `O(1)`    \r\n>   Only constant variables for keeping latest position and direction\r\n\r\n## Note\r\n\r\n- The key of this problem is to think of the condition of final direction.\r\n\r\n- Visualize the process:\r\n\r\n```python\r\nplt.figure(figsize=(32, 6))\r\nfor i in range(4):\r\n    init_position = [0, 0]\r\n    position = [0, 0]\r\n    init_direction = (0, 1)\r\n    direction = (0, 1)\r\n    plt.subplot(1,5,i+1)\r\n    plt.title(\"Run instructions Iteration \" + str(i+1))\r\n    plt.scatter(position[0], position[1], c='g')\r\n    plt.arrow(position[0], position[1] ,dx=direction[0]*0.3,dy=direction[1]*0.3, head_width=0.5, head_length=0.3, fc='g', ec='g')\r\n    for i in range(i+1):\r\n        iteration = 0\r\n        for instruction in instructions:\r\n            if instruction == \"G\":\r\n                position[0] += direction[0]\r\n                position[1] += direction[1]\r\n            elif instruction == \"L\":\r\n                if direction == (0, 1):\r\n                    direction = (-1, 0)\r\n                elif direction == (-1, 0):\r\n                    direction = (0, -1)\r\n                elif direction == (0, -1):\r\n                    direction = (1, 0)\r\n                else:\r\n                    direction = (0, 1)\r\n            else:\r\n                if direction == (0, 1):\r\n                    direction = (1, 0)\r\n                elif direction == (1, 0):\r\n                    direction = (0, -1)\r\n                elif direction == (0, -1):\r\n                    direction = (-1, 0)\r\n                else:\r\n                    direction = (0, 1)\r\n            plt.scatter(position[0], position[1], c='b')\r\n            plt.arrow(position[0], position[1] ,dx=direction[0]*0.3,dy=direction[1]*0.3, head_width=0.5, head_length=0.3, fc='b', ec='b')\r\n            iteration += 1\r\n    plt.scatter(position[0], position[1], c='r')\r\n    plt.arrow(position[0], position[1] ,dx=direction[0]*0.3,dy=direction[1]*0.3, head_width=0.5, head_length=0.3, fc='r', ec='r')\r\n    plt.grid()\r\nplt.show()\r\n```\r\n\r\n![](https://i.imgur.com/tlGlvrC.png)\r\n\r\n![](https://i.imgur.com/0Un2vT4.png)\r\n\r\n- Remember to read the description carefully!\r\n\r\n###### tags: `Coding`"}},"staticQueryHashes":[]}