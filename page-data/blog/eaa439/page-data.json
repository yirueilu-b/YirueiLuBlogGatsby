{"componentChunkName":"component---src-templates-post-js","path":"/blog/eaa439","result":{"pageContext":{"md_path":"leetcode3","title":"LeetCode 3. Longest Substring Without Repeating Characters","description":"Given a string s, find the length of the longest substring without repeating characters.Example 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The an...","image":"https://dkmonster.github.io/assets/images/leetcode/LeetCode_Sharing.png","uuid":"eaa439","text":"# LeetCode 3. Longest Substring Without Repeating Characters\r\n\r\n![](https://dkmonster.github.io/assets/images/leetcode/LeetCode_Sharing.png)\r\n\r\n## Description\r\n\r\nGiven a string `s`, find the length of the **longest substring** without repeating characters.\r\n\r\n**Example 1:**\r\n```\r\nInput: s = \"abcabcbb\"\r\nOutput: 3\r\nExplanation: The answer is \"abc\", with the length of 3.\r\n```\r\n**Example 2:**\r\n```\r\nInput: s = \"bbbbb\"\r\nOutput: 1\r\nExplanation: The answer is \"b\", with the length of 1.\r\n```\r\n**Example 3:**\r\n```\r\nInput: s = \"pwwkew\"\r\nOutput: 3\r\nExplanation: The answer is \"wke\", with the length of 3.\r\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\r\n```\r\n**Example 4:**\r\n```\r\nInput: s = \"\"\r\nOutput: 0\r\n```\r\n\r\n**Constraints:**\r\n- `0 <= s.length <= 5 * 104`\r\n- `s` consists of English letters, digits, symbols and spaces.\r\n\r\n## Idea\r\n\r\n**Idea 1**\r\n\r\nBrute force, go trough all substrings of `s`, for example: given `s = \"abc\"`, we could easily find its all substrings is `[\"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\"]` by using for loops, and we could check if each subtring is repeating and keep lenghth of longest substring without repeating while iterating through the substrings\r\n\r\n**Idea 2**\r\n\r\nUsing a sliding widow and keep the substring in window be always without duplicate characters by contracting and extending it\r\n\r\n**Idea 3**\r\n\r\nWe could further optimize sliding widow idea by optimizing the contracting step.\r\nIn sliding widow idea, when we encounter duplicate character `c`, we contract the window by moving left pointer one by one untill we met the same character.\r\nWe could just keep the previous index of each character then we are able to take only one step to contract the window to the right position.\r\n\r\n## Solution\r\n\r\n**Solution 1 (TLE)**\r\n\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        ans = 0\r\n        for i in range(len(s)):\r\n            for j in range(i+1, len(s)+1):\r\n                temp = {}\r\n                is_repeat = False\r\n                for letter in s[i:j]:\r\n                    if letter not in temp:\r\n                        temp[letter] = 1\r\n                    else:\r\n                        is_repeat = True\r\n                        break\r\n                if not is_repeat:\r\n                    ans = max(ans, len(temp))\r\n        return ans\r\n```\r\n\r\n> **Complexity**\r\n> - Time complexity: `O(n^3)`        \r\n>   For all substrings `O(n^2)` need `O(n)` to check if duplicate\r\n> - Space complexity: `O(m)`    \r\n>   `m` is the number of characters in given character set\r\n\r\n**Solution 2**\r\n\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        ans = 0\r\n        left = 0\r\n        right = 0\r\n        # [32, 126] are ascii value for all eglish letters, digits, symbols and spaces\r\n        # if not remenbering the ascii range, just use an empty dict and check if character is in the dict\r\n        # but it takes extra time to check existence\r\n        history = dict(zip([chr(i) for i in range(32, 127)], [0 for _ in range(32, 127)]))    \r\n        for i in range(len(s)):\r\n            history[s[i]] += 1\r\n            while history[s[i]] > 1:\r\n                history[s[left]] -= 1\r\n                left += 1\r\n            ans = max(ans, i-left+1)\r\n        return ans\r\n```\r\n\r\n> **Complexity**\r\n> - Time complexity: `O(n)`        \r\n>   Maximum is `2n` of contracting and extending\r\n> - Space complexity: `O(m)`\r\n\r\n**Solution 3**\r\n\r\n```python\r\ndef lengthOfLongestSubstring(s: str) -> int:\r\n    ans = 0\r\n    left = 0\r\n    history = dict(zip([chr(i) for i in range(32, 127)], [-1 for _ in range(32, 127)]))\r\n    for i, c in enumerate(s):\r\n        if left <= history[c] < i: \r\n            left = history[c] + 1\r\n        else: \r\n            ans = max(ans, i-left+1)\r\n        history[c] = i\r\n    return ans\r\n```\r\n\r\n> **Complexity**\r\n> - Time complexity: `O(n)`\r\n> - Space complexity: `O(m)`\r\n\r\n## Note\r\n\r\n**Visualize Optimized Sliding Window Approach**\r\n\r\n```python\r\ns = 'abcabcbb'\r\ns = list(s)\r\nlength = len(s)\r\nheight = 1\r\n\r\nhistory_ans = []\r\nhistory_dict = []\r\nhistory_left = []\r\nhistory_right = []\r\nhistory_repeat = []\r\n\r\nans = 0\r\nleft = 0\r\nhistory = dict(zip([chr(i) for i in range(32, 127)], [-1 for _ in range(32, 127)]))\r\nfor i, c in enumerate(s):\r\n    if left <= history[c] < i:\r\n        history_ans.append(ans)\r\n        history_dict.append([\"{}:{}\".format(k, v) for k, v in history.items() if v > -1])\r\n        history_left.append(left)\r\n        history_right.append(i)\r\n        history_repeat.append(True)\r\n        left = history[c] + 1\r\n        history_ans.append(ans)\r\n        history_dict.append([\"{}:{}\".format(k, v) for k, v in history.items() if v > -1])\r\n        history_left.append(left)\r\n        history_right.append(i)\r\n        history_repeat.append(False)\r\n    else:\r\n        ans = max(ans, i-left+1)\r\n        history_ans.append(ans)\r\n        history_dict.append([\"{}:{}\".format(k, v) for k, v in history.items() if v > -1])\r\n        history_left.append(left)\r\n        history_right.append(i)\r\n        history_repeat.append(False)\r\n    history[c] = i\r\n```\r\n```python\r\nfig = plt.figure(figsize=(int(length * 1.5), int(4 * 1.5)))\r\nax = fig.add_subplot(111)\r\nax.set_xlim(-1, length + 1)\r\nax.set_ylim(-1.5, 2.5)\r\n# plot rectangles and letters for `s` array\r\nfor i in range(length):\r\n    plt.plot([i, i], [height, 0], c='steelblue', lw=1)[0]\r\n    plt.text(i + 0.5 - 0.08 * len(str(i)), 1 + 0.08, i, fontsize=10, color='steelblue')\r\n    plt.text(i + 0.5 - 0.09, 0.5 - 0.09, s[i], fontsize=14, color='k')\r\narr_rect = patches.Rectangle((0, 0), length, height, lw=1, fill=0, ec='steelblue')\r\n# init title\r\ntitle = plt.title('i = {}\\ncurrent number of ones = {}\\nans = {}'.format('init', 0, 0), fontsize=14)\r\n# highlight ones\r\nindex_rect = patches.Rectangle((0, 0), 0, 0, lw=1, fc=(0.19607843, 0.80392157, 0.19607843, 0.2))\r\n# point out current index\r\narrow_i = plt.arrow(0, 0, 0, 0, head_width=0, color='k')\r\narrow_j = plt.arrow(0, 0, 0, 0, head_width=0, color='k')\r\ntext_i = plt.text(0, 2.1, '', fontsize=10, color='k')\r\ntext_j = plt.text(0, 1.9, '', fontsize=10, color='k')\r\n\r\n# animation init\r\ndef init():\r\n    ax.add_patch(arr_rect)\r\n    ax.add_patch(index_rect)\r\n    ax.add_patch(arrow_i)\r\n    ax.add_patch(arrow_j)\r\n    return \r\n\r\n# animation function, iterate through the result\r\ndef animate(frame):\r\n    title.set_text('iteration = {}\\ndict = {}\\ncurrent ans = {}'.format(frame, history_dict[frame], history_ans[frame]))\r\n    index_rect.set_width(history_right[frame] - history_left[frame] + 1)\r\n    index_rect.set_height(1)\r\n    index_rect.set_xy([history_left[frame], 0])\r\n    index_rect.set_color((0.19607843, 0.80392157, 0.19607843, 0.2))\r\n    if history_repeat[frame]:\r\n        index_rect.set_color((0.80392157, 0.19607843, 0.19607843, 0.2))\r\n    if frame > 0:\r\n        ax.patches.remove(ax.patches[-1])\r\n        ax.patches.remove(ax.patches[-1])\r\n        ax.patches.remove(ax.patches[-1])\r\n        ax.patches.remove(ax.patches[-1])\r\n    arrow_i = plt.arrow(history_left[frame] + 0.5, 1.8, 0, -0.25, head_width=0.1, color='k')\r\n    arrow_j = plt.arrow(history_right[frame] + 0.5, 1.8, 0, -0.25, head_width=0.1, color='k')\r\n    ax.add_patch(arrow_i)\r\n    ax.add_patch(arrow_j)\r\n    text_i.set_x(history_left[frame]+0.35)\r\n    text_j.set_x(history_right[frame]+0.35)\r\n    text_i.set_text(\"left={}\".format(history_left[frame]))\r\n    text_j.set_text(\"right={}\".format(history_right[frame]))\r\n    return \r\n    \r\n# hide axis\r\nanim = animation.FuncAnimation(fig, \r\n                               func=animate,\r\n                               init_func=init,\r\n                               frames=len(history_ans),\r\n                               interval=0.9487*1000,\r\n                              )\r\nplt.axis('off')\r\nanimation_html = HTML(anim.to_jshtml())\r\n# prevent plt show the final plot\r\nplt.close()\r\nanimation_html\r\n```\r\n\r\n![](https://github.com/yirueilu-b/coding-problems-and-notes/raw/master/leetcode/3_longest_substring_without_repeating_characters_sliding_window_opt.gif)\r\n\r\n###### tags: `Coding`"}},"staticQueryHashes":[]}